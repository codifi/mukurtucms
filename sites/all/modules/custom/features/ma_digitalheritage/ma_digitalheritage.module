<?php
/**
 * @file
 * Code for the Digital Heritage Metadata Import feature.
 */

include_once('ma_digitalheritage.features.inc');

/**
 * Implements hook_node_presave().
 */
function ma_digitalheritage_node_presave($node) {
  if ($node->type == 'digital_heritage') {

    $dh_emw = entity_metadata_wrapper('node', $node);

    // Set the community record parent if the session var for such was set in ma_digitalheritage_form_digital_heritage_node_form_alter
    if (isset ($_SESSION['community_record_parent'])) {
      $node->field_community_record_parent[LANGUAGE_NONE][0]['target_id'] = $_SESSION['community_record_parent'];
      unset ($_SESSION['community_record_parent']);
    }

    // Update the Community field according to the protocols for the DH node. The community field is a noderef field hidden from the node form, but displayed on the node view and search results view (and used as a search facet). It is a hidden noderef field (as opposed to group field) because we can only have one group field per node type and that's already used for the protocol.
    $communities = array();
    foreach ($dh_emw->og_group_ref->value() as $protocol) {
      $p_emw = entity_metadata_wrapper('node', $protocol);
      foreach ($p_emw->og_group_ref->value() as $community) {
        $communities[] = $community->nid;
      }
    }
    if (count($communities)) {
      $dh_emw->field_community_ref->set(array_unique($communities));
    }

  }
}
/**
 * Implements hook_node_update().
 */
function ma_digitalheritage_node_update($node) {
  if ($node->type == 'digital_heritage') {

    $dh_emw = entity_metadata_wrapper('node', $node);
    $dh_emw_old = entity_metadata_wrapper('node', $node->original);

    // If this is a Book Child, reindex the parent
    $book_parent = $dh_emw->field_book_parent->value();
    if (count($book_parent)) {
      search_api_index_specific_items_delayed (search_api_index_load('default_node_index'), array($book_parent->nid));
    }

    // If this is a Book Parent, replicate some field values to its book children
    $book_children = $dh_emw->field_book_children->value();
    if (count($book_children)) {

      // Replicate the Protocols (if changed) (their Communities will get set in their own wrapper save below)
      if (array_values($dh_emw->og_group_ref->value()) <> array_values($dh_emw_old->og_group_ref->value())) {
        foreach ($book_children as $child_page) {
          foreach ($dh_emw->og_group_ref->value() as $protocol) {
            $parent_protocols[] = $protocol->nid;
          }
          if (count($parent_protocols)) {
            $book_child_wrapper = entity_metadata_wrapper('node', $child_page);
            $book_child_wrapper->og_group_ref->set(array_unique($parent_protocols));
            $book_child_wrapper->save();
          }
        }
        #dpm ('groups changed on children');
      }

      // Replicate the privacy setting (if changed)
      if ($dh_emw->field_item_privacy_setting->value() <> $dh_emw_old->field_item_privacy_setting->value()) {
        foreach ($book_children as $child_page) {
          $book_child_wrapper = entity_metadata_wrapper('node', $child_page);
          $book_child_wrapper->field_item_privacy_setting->set($dh_emw->field_item_privacy_setting->value());
          $book_child_wrapper->save();
        }
        #dpm ('privacy setting changed on children');
      }

    }
  }
}


/**
 * Implements hook_form_FORM_ID_alter().
 */
function ma_digitalheritage_form_views_exposed_form_alter(&$form, &$form_state) {

  // Add a button to reset search and filters
  // Search API provides a button on the view that will reset the search, but not the filters. Leaving that off and creating our own that will reset both.
  if (strpos($form['#id'], 'views-exposed-form-digital-heritage-grid-list') !== FALSE) {
    if (count(arg()) > 1 OR count(drupal_get_query_parameters())) {
      $form['reset'] = array('#markup' => l(t('Reset'),'digital-heritage', array('attributes' => array('class' => array ('btn', 'btn-primary', 'form-submit')), 'html' => TRUE)));
    }
  }

}

/**
 * Implements template_preprocess_views_view.
 */
function ma_digitalheritage_preprocess_views_view(&$vars) {
  $view = &$vars['view'];

  // Add JS for browse mode switcher on DH view
  if ($view->name == 'digital_heritage_grid_list') {
    drupal_add_library('system', 'jquery.cookie');
    drupal_add_js(drupal_get_path('module', 'ma_digitalheritage') . '/js/dh_browse_mode_switcher.js');
  }
}

/**
 * Implements hook_user_logout().
 */
// Delete the cookie that holds the DH browse mode setting
function ma_digitalheritage_user_logout ($account) {
  setcookie('dh_browse_mode', '', 1, '/');
}

/**
 * Implementation of hook_node_view().
 */
function ma_digitalheritage_node_view($node, $view_mode) {

  if ($node->type == 'digital_heritage') {

    if ($view_mode == 'search_result') {

      // Tooltip and links on DH grid/list views

      // If no media items at all on the DH item and in grid view, put a placeholder image
      if (!$node->field_media_asset) {
        $node->content['field_media_asset'][0]['#markup'] = '
      <div class="col-md-4 col-md-push-8 field field-name-field-media-asset field-type-atom-reference field-label-hidden">
        <div class="field-items">
            <a class = "tooltips image-placeholder" href=" ' . url("node/" . $node->nid) . '"><img src = "/' . drupal_get_path('module', 'ma_digitalheritage') . '/images/no_media_available.jpg"></a>
        </div>
      </div>';
      }

    }

    elseif ($view_mode == 'full') {

      // Hide the Related Items Teasers if the option is not selected
      if (variable_get('mukurtu_show_related_items_teasers') <> 1) {
        unset ($node->content['dh_related_items_teasers']);
      }

      // Rewrite the Related DH Items reference field as paged, since there can be hundreds. This is a dupe of the same thing in ma_collection_node_view. See comments there if changing here, should also be changed there.

      $dh_items_per_page = 10;

      // Build the array of all DH items
      if (isset($node->field_related_dh_items[LANGUAGE_NONE])) {
        $all_dh_items = array();
        foreach ($node->field_related_dh_items[LANGUAGE_NONE] as $index => $dh_item) {
          unset ($node->content['field_related_dh_items'][$index]); // Start rewriting the field by removing the existing DH items
          if (node_access('view', $dh_item['entity'])) {
            $dh_node = node_view($dh_item['entity'], 'search_result');
            $all_dh_items[] = drupal_render($dh_node); // Need to render here as opposed to using "rendered entity" in the DS display, as that will attemt to render them *after* this hook runs
          }
        }

        // Initialise the pager
        $current_page = pager_default_initialize(count($all_dh_items), $dh_items_per_page);

        // Split all DH items into pages
        $pages = array_chunk($all_dh_items, $dh_items_per_page, TRUE);

        // Print the DH items for the current page
        $output = "";
        foreach ($pages[$current_page] as $dh_item_to_display) {
          $output .= $dh_item_to_display;
        }

        // Print the pager
        $output .= theme('pager', array('quantity', count($dh_items_per_page)));

        // Rewrite the field output
        $node->content['field_related_dh_items'][0]['#markup'] = $output;
      }


    }
    elseif ($view_mode == 'community_record') {

      // Add an edit link to community record after its title
      $node->content['title'][0]['#markup'] = $node->title . l(' (edit)', 'node/' . $node->nid . '/edit');
    }

  }

}

/**
 * Implements hook_comment_insert().
 */
function ma_digitalheritage_comment_insert($comment) {

  // Notify protocol steward(s) when a comment has been posted to one of their Cultural Protocols that requires approval
  if ($comment->node_type == 'comment_node_digital_heritage') {
    if ($comment->status) return; // comment is pre-approved (eg. posted by admin)
    $dh_emw = entity_metadata_wrapper('node', $comment->nid);

    // Build the array of protcol manager emails from the protocol steward(s) of the given protocol(s) for this DH node
    if ($cps = $dh_emw->og_group_ref->value()) {
      $protocol_managers_emails = array();
      foreach ($cps as $cp) {
        $cp_emw = entity_metadata_wrapper('node', $cp);
        if ($protocol_managers = ma_core_og_get_users_per_role_and_group ('protocol steward', 'cultural_protocol_group', $cp->nid)) {
          foreach ($protocol_managers as $protocol_manager) {
            $protocol_managers_emails[] = $protocol_manager->name . ' <' . $protocol_manager->mail . '>';
          }
        }
      }

      // Send the email (the body and subject get built in ma_digitalheritage_mail)
      if (count($protocol_managers_emails)) {
        $params = array (
          'comment' => $comment,
          'cp_emw' => $cp_emw,
          'dh_emw' => $dh_emw,
          'recipient_count' => count ($protocol_managers_emails),
        );
        drupal_mail('ma_digitalheritage', 'dh_comment_notification', implode (', ', $protocol_managers_emails), language_default(), $params);
      }
    }
  }
}

/*
 * Implementation of hook_mail().
*/
function ma_digitalheritage_mail($key, &$message, $params) {
  switch ($key) {
    case 'dh_comment_notification':
      $comment = $params['comment'];
      $cp_title = $params['cp_emw']->title->value();

      // Set the email subject
      $message['subject'] = "A comment in '" . $cp_title . "' requires your approval";

      // Set the email body
      $email_body  = "A comment has been posted that requires your approval.\n\n";
      $email_body .= "Cultural Protocol:\n" . $cp_title . "\n\n";
      $email_body .= "Digital Heritage:\n" . $params['dh_emw']->title->value() . "\n\n";
      $comment_author = user_load ($comment->uid);
      $email_body .= "Comment author:\n" . $comment_author->name . "\n\n";
      if ($comment->subject) {
        $email_body .= "Comment subject:\n". $comment->subject . "\n\n";
      }
      $comment_body = $comment->comment_body[LANGUAGE_NONE][0]['value'];
      $comment_body = drupal_html_to_text ($comment_body);
      $email_body  .= "Comment body:\n" . $comment_body . "\n\n";
      $email_body .= "Click " . l('here', 'node/' . $comment->nid, array('fragment' => 'comment-' . $comment->cid)) . " to approve or delete this comment";
      if ($params['recipient_count'] > 1) {
        $email_body .= " (more than one Protocol Stewards have received this notification, so the comment may already be approved or deleted at this time)";
      }
      $email_body .= ".";
      $message['body'][] = $email_body;

      break;
  }
}

/**
 * Implements hook_views_pre_build().
 */
function ma_digitalheritage_views_pre_build(&$view) {

  // Override the "View All" (DH Items) path to the sapi page
  if ($view->name == 'community_dh_items') {
    $view->override_path = 'digital-heritage/' . $view->current_display;
  }
}

/**
 * Implements hook_menu().
 */
function ma_digitalheritage_menu() {
  $items = array();

  // "Duplicate Item" button for DH node
  $items['node/%node/duplicate-item'] = array(
    'title' => 'Duplicate Item',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ma_digitalheritage_clone_dh_form', 1),
    'access callback' => 'ma_digitalheritage_clone_dh_button_check',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 100,
  );

  // "Add Community Record" button for DH node
  $items['node/%node/add-community-record'] = array(
    'title' => 'Add Community Record',
    'page callback' => 'ma_digitalheritage_add_community_record',
    'page arguments' => array(1),
    'access callback' => 'ma_digitalheritage_add_cr_check',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 100,
  );

  // "Add a Book Page" button for DH node
  $items['node/%node/add-book-page'] = array(
    'title' => 'Add a Book Page',
    'page callback' => 'ma_digitalheritage_add_book_page',
    'page arguments' => array(1),
    'access callback' => 'ma_digitalheritage_add_book_page_check',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 100,
  );

  // Callback that toggles the display of the Related Items teasers
  $items['admin/toggle-related-items-teasers'] = array(
    'title' => 'Toggle Related Items Teasers',
    'page callback' => 'ma_digitalheritage_toggle_related_items_teasers',
    'access arguments' => array('administer site configuration'),
    'type' => MENU_CALLBACK,
    'weight' => 100,
  );

  return $items;
}

function ma_digitalheritage_clone_dh_button_check($node) {
  if ($node->type == 'digital_heritage') {
    $dh_emw = entity_metadata_wrapper('node', $node);
    if ($dh_emw->field_book_parent->value() OR $dh_emw->field_book_children->value()) { // Do not allow cloning or creating community records on book pages, whether child or parent
      return FALSE;
    }
    foreach ($dh_emw->og_group_ref->value() as $protocol) {
      if (isset ($protocol)) {
        $p_emw = entity_metadata_wrapper('node', $protocol);
        $roles_for_user_in_group = og_get_user_roles('node', $p_emw->getIdentifier());
        if (array_intersect(array('protocol steward'), $roles_for_user_in_group)) {
          return TRUE;
        }
      }
    }
  }
}

function ma_digitalheritage_add_cr_check($node) {
  if ($node->type == 'digital_heritage') {
    $dh_emw = entity_metadata_wrapper('node', $node);
    foreach ($dh_emw->og_group_ref->value() as $protocol) {
      if (isset ($protocol)) {
        $p_emw = entity_metadata_wrapper('node', $protocol);
        $roles_for_user_in_group = og_get_user_roles('node', $p_emw->getIdentifier());
        if (array_intersect(array('protocol steward'), $roles_for_user_in_group)) {
          return TRUE;
        }
      }
    }
  }
}

function ma_digitalheritage_add_book_page_check($node) {
  if ($node->type == 'digital_heritage') {
    global $user;
    if ($node->uid == $user->uid) { // Only owners of nodes can create child book pages for it
      return TRUE;
    }
  }
}

function ma_digitalheritage_toggle_related_items_teasers () {
  if (variable_get('mukurtu_show_related_items_teasers')) {
    variable_set ('mukurtu_show_related_items_teasers', 0);
  }
  else {
    variable_set ('mukurtu_show_related_items_teasers', 1);
  }
  drupal_goto ('dashboard');
}

function ma_digitalheritage_clone_dh_form($form, $form_state, $node) {
  $question = "<i>Duplicate Digital Heritage Item</i> " . $node->title;
  $description = "<div>Are you sure?</div>";
  return confirm_form($form, $question, 'node/' . $node->nid, $description);
}

function ma_digitalheritage_clone_dh_form_submit($form, $form_state) {

  // Clone the node with a new title
  $original_nid = arg(1);
  $cloned = replicate_clone_entity_by_id ('node', $original_nid);
  $cloned->title = $cloned->title . ' - copy';
  node_save ($cloned);

  // Unset any CPs that the cloning protocol steward is not a contributor or protocol steward for
  $protocols_to_set = array();
  $dh_emw = entity_metadata_wrapper('node', $cloned);
  foreach ($dh_emw->og_group_ref->value() as $protocol) {
    $p_emw = entity_metadata_wrapper('node', $protocol);
    $roles_for_user_in_group = og_get_user_roles('node', $p_emw->getIdentifier());
    if (array_intersect(array('protocol steward', 'contributor'), $roles_for_user_in_group)) {
      $protocols_to_set[] = $protocol;
    }
  }
  $dh_emw->og_group_ref->set ($protocols_to_set);

  // Make a relationship to the original node
  $dh_emw->field_related_dh_items[] = $original_nid;

  // Save our changes
  $dh_emw->save();

  // Go to the cloned node
  drupal_set_message(t("Successfully duplicated Digital Heritage item"));
  drupal_goto ('node/' . $cloned->nid);
}

// When renaming a cloned node, do not create a URL redirect from the old node, because a newly cloned node from the original node might take the original path of 1st cloned node, thus you would always be redirected to the 1st cloned node from the 2nd cloned node. This is not an edge case. It would happen in normal node cloning workflow, as it did during our tests.
function ma_digitalheritage_redirect_presave($redirect) {
  if (strpos($redirect->source, '-copy')) {
    $redirect->source = "dh_clone_redirect"; // cannot simply unset the $redirect here so setting a dummy source instead
  }
}


// "Add Community Record" button redirect to node edit form with community-record param
function ma_digitalheritage_add_community_record ($node) {
  drupal_goto ('node/add/digital-heritage/community-record/' . $node->nid);
}

// "Add a Book Page" button redirect to node edit form with book-page param
function ma_digitalheritage_add_book_page ($node) {
  drupal_goto ('node/add/digital-heritage/book-page/' . $node->nid);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function ma_digitalheritage_form_digital_heritage_node_form_alter(&$form, &$form_state) {

  // Always hide these fields
  $form['field_book_parent']['#access'] = FALSE;

  // Grab Community Record parent on node edit and set page title
  if (isset($form['field_community_record_parent'][LANGUAGE_NONE]['#default_value'][0])) {
    $community_record_parent_wrapper = entity_metadata_wrapper('node', $form['field_community_record_parent'][LANGUAGE_NONE]['#default_value'][0]);

    // Set the page title
    drupal_set_title ("<i>Edit Community Record</i> " . $form['#node']->title . " <i>in</i> " . $community_record_parent_wrapper->title->value(),  PASS_THROUGH);
  }

  // On Community Record add, ensure the user actually has permission to create a community record on this node, in case they hacked NID in the url, and then set the community record parent wrapper and page title, and then set the session var for community record parent.
  elseif (arg(3) == 'community-record') {
    $parent_dh_wrapper = entity_metadata_wrapper('node', arg(4));
    foreach ($parent_dh_wrapper->og_group_ref->value() as $protocol) {
      $p_emw = entity_metadata_wrapper('node', $protocol);
      $roles_for_user_in_group = og_get_user_roles('node', $p_emw->getIdentifier());
      if (array_intersect(array('protocol steward'), $roles_for_user_in_group)) {

        // Set the parent wrapper
        $community_record_parent_wrapper = $parent_dh_wrapper;

        // Set the page title
        drupal_set_title ("<i>Create Community Record in</i> " . $community_record_parent_wrapper->title->value(),  PASS_THROUGH);

        // Use a session var to set the parent community record nid. This then gets set in the child in ma_digitalheritage_node_presave. (we cannot set the field value here because it is a hidden form element)
        $_SESSION['community_record_parent'] = arg(4);

        break;
      }
    }
  }

  // Customizations to Community Record DH nodes
  if (isset($community_record_parent_wrapper)) {

    // Hide some fields
    $hide_fields = array(
      'field_media_asset',
      'field_collection',
      'field_related_dh_items',
      'field_community_record_children',
    );
    foreach ($hide_fields as $hide_field) {
      $form[$hide_field]['#access'] = FALSE;
    }

  }

  // Grab Book Page parent on node edit and set page title
  if ($form['field_book_parent'][LANGUAGE_NONE][0]['target_id']['#default_value']) {
    $book_child_page = 1;

    // Set the page title
    $book_parent = $form['field_book_parent'][LANGUAGE_NONE][0]['target_id']['#entity'];
    drupal_set_title ("<i>Edit Book Page</i> " . $form['#node']->title . " <i>in</i> " . $book_parent->title,  PASS_THROUGH);
  }

  // On Book Page add, ensure the user actually has permission to create a Book Page on this node, in case they hacked NID in the url, and then set the page title, set the parent, and set the protocols and privacy setting
  elseif (arg(3) == 'book-page') {
    $referring_node = node_load (arg(4));
    global $user;
    if (ma_digitalheritage_add_book_page_check($referring_node)) { // The permission check
      $book_child_page = 1;
      if (isset ($referring_node->field_book_parent[LANGUAGE_NONE][0]['target_id'])) { // This book child page is being added from another book child page
        $book_parent = node_load ($referring_node->field_book_parent[LANGUAGE_NONE][0]['target_id']);
      }
      else {
        $book_parent = $referring_node; // This book child page is being added from the parent book page
      }

      // Set the page title
      drupal_set_title ("<i>Create Book Page in</i> " . $book_parent->title,  PASS_THROUGH);

      // Set the parent
      $form['field_book_parent'][LANGUAGE_NONE][0]['target_id']['#value'] = $book_parent->title . ' (' . $book_parent->nid . ')'; // setting in the autocomplete widget format

      // Set the privacy setting and protocols to that of the parent
      $book_parent_wrapper = entity_metadata_wrapper('node', $book_parent);
      $form['field_item_privacy_setting'][LANGUAGE_NONE]['#value'] = $book_parent_wrapper->field_item_privacy_setting->value();
      foreach ($book_parent_wrapper->og_group_ref->value() as $protocol) {
        $form['og_group_ref'][LANGUAGE_NONE]['#default_value'][] = $protocol->nid;
      }
    }

  }

  // Customizations to Book Child Page
  if (isset($book_child_page)) {
    $hide_fields = array(
      'field_item_privacy_setting',
      'field_book_children',
      'field_community_record_children',
      'field_related_dh_items',
      'field_collection',
    );
    foreach ($hide_fields as $hide_field) {
      $form[$hide_field]['#access'] = FALSE;
    }

  }

}

/**
 * Implements hook_node_validate().
 */
function ma_digitalheritage_node_validate($node, $form, &$form_state) {
  if ($node->type == 'digital_heritage') {
      $original_node = node_load($node->nid);

    // Do not allow adding, changing, or removing of Community Records in the DH node form. The field is there only to allow users to reorder the Community Records.
    $original_community_records = array();
    if(isset($original_node->field_community_record_children)) {
        foreach($original_node->field_community_record_children[LANGUAGE_NONE] as $original_child) {
            $original_community_records[] = $original_child['target_id'];
        }
    }

    $new_community_records = array();
    if(isset($node->field_community_record_children)) {
        foreach($node->field_community_record_children[LANGUAGE_NONE] as $new_child) {
            if(isset($new_child['target_id']) && is_numeric($new_child['target_id'])) {
                $new_community_records[] = $new_child['target_id'];
                if (!in_array($new_child['target_id'], $original_community_records)) {
                    form_set_error('field_community_record_children', t('Do not add Community Records here. Use the "Add Community Record" button instead.'));
                }
            }
        }
    }

    foreach ($original_community_records as $original_child) {
      if (!in_array($original_child, $new_community_records)) {
        form_set_error('field_community_record_children', t('Do not remove Community Records here. Instead, edit the Community Record, then press "Delete". Note, only the creator of the Community Record can delete it.'));
      }
    }

    // Do not allow adding, changing, or removing of Book Pages in the DH node form. The field is there only to allow users to reorder the Book Pages.
    $original_book_pages = array();
    if(isset($original_node->field_book_children)) {
        foreach($original_node->field_book_children[LANGUAGE_NONE] as $original_child) {
            $original_book_pages[] = $original_child['target_id'];
        }
    }

    $new_book_pages = array();
    if(isset($node->field_book_children)) {
        foreach($node->field_book_children[LANGUAGE_NONE] as $new_child) {
            if(isset($new_child['target_id']) && is_numeric($new_child['target_id'])) {
                $new_book_pages[] = $new_child['target_id'];
                if (!in_array($new_child['target_id'], $original_book_pages)) {
                    form_set_error('field_book_children', t('Do not add Book Pages here. Use the "Add a Book Page" button instead.'));
                }
            }
        }
    }

    foreach ($original_book_pages as $original_child) {
      if (!in_array($original_child, $new_book_pages)) {
        form_set_error('field_book_children', t('Do not remove Book Pages here. Instead, edit the Book Page, then press "Delete".'));
      }
    }
    
  }
}


/**
 * Implements hook_node_insert().
 */
function ma_digitalheritage_node_insert($node) {
  if ($node->type == 'digital_heritage') {

    $dh_emw = entity_metadata_wrapper('node', $node);

    // If this is a Book Child, reindex the parent
    $book_parent = $dh_emw->field_book_parent->value();
    if (count($book_parent)) {
      search_api_index_specific_items_delayed (search_api_index_load('default_node_index'), array($book_parent->nid));
    }

    // Create redirects on Community Record nodes to their parent
    if (isset($node->field_community_record_parent[LANGUAGE_NONE][0]['target_id'])) {
      $redirect = new stdClass();
      redirect_object_prepare(
        $redirect,
        array(
          'source' => 'node/' . $node->nid,
          'source_options' => array(),
          'redirect' => 'node/' . $node->field_community_record_parent[LANGUAGE_NONE][0]['target_id'],
          'redirect_options' => array(),
          'language' => LANGUAGE_NONE,
        )
      );
      redirect_save($redirect);
    }
  }
}

/**
 * Implements hook_node_delete().
 */
function ma_digitalheritage_node_delete($node) {
  if ($node->type == 'digital_heritage') {
    $dh_emw = entity_metadata_wrapper('node', $node);

    // Delete the Community Records of a parent DH if the parent is deleted
    foreach ($dh_emw->field_community_record_children->value() as $child) {
      if (isset($child->nid)) {
        if ($child->nid <> $node->nid) { // In case a Community Record is a child of itself (which shouldn't happen but just in case to prevent infinite loop)
          node_delete($child->nid);
        }
      }
    }

    // Delete the child pages of a book if the parent is deleted
    foreach ($dh_emw->field_book_children->value() as $child) {
      if (isset($child->nid)) {
        if ($child->nid <> $node->nid) { // In case a book page is a child of itself (which shouldn't happen but just in case to prevent infinite loop)
          node_delete($child->nid);
        }
      }
    }

  }
}

/**
 * Implements hook_search_api_index_items_alter().
 */
function ma_digitalheritage_search_api_index_items_alter(array &$items, SearchApiIndex $index) {
  foreach($items as $id => $item){

    // Exclude Community Record DH nodes from being indexed
    if (isset($item->field_community_record_parent[LANGUAGE_NONE])) {
     unset($items[$id]);
    }

    // Exclude DH Child pages from being indexed
    if (isset($item->field_book_parent[LANGUAGE_NONE])) {
      unset($items[$id]);
    }

  }
}


/**
 * Implements hook_node_load().
 */
function ma_digitalheritage_node_load($nodes, $types) {

  // For Community Records, show the parent record's atoms
  if (in_array('digital_heritage', $types)) {
    foreach ($nodes as $node) {
      if (isset($node->field_community_record_parent[LANGUAGE_NONE])) {
        $parent_node = node_load ($node->field_community_record_parent[LANGUAGE_NONE][0]['target_id']);
        if (isset($parent_node->field_media_asset[LANGUAGE_NONE])) {
          $node->field_media_asset = $parent_node->field_media_asset;
        }
      }
    }
  }
}

/**
 * Implements hook_page_alter().
 */
function ma_digitalheritage_page_alter(&$data) {

  // If there are Child Records for a DH node, show the parent and child records in quicktabs
  if (isset($data['content']['system_main']['nodes']) && !isset($data['content']['system_main']['term_heading']['term'])) {
    $array_keys = array_keys($data['content']['system_main']['nodes']);
    $node = $data['content']['system_main']['nodes'][array_shift($array_keys)]["#node"];
    if ($node->type == 'digital_heritage') {

      // Custom build page content for DH nodes
      $nids = element_children($data['content']['system_main']['nodes']);
      $nid = $nids[0];

      // Book pages
      if ($node->field_book_children OR $node->field_book_parent) {

        // Show navigation buttons
        $dh_page_content = ma_digital_heritage_book_page_navigation_buttons($node);

        // Show table of contents on parent (page 1) of book only
        if ($node->field_book_children) {
          $dh_page_content .= '<div class = "dh-book-toc">' . theme(
            'ctools_collapsible',
            array(
              'handle' => '<h3 class = "dh-book-toc-header">' . 'Table of Contents' . '</h3>',
              'content' => ma_digital_heritage_book_page_contents($node),
              'collapsed' => TRUE,
            )
          ) . '</div>';
        }
      }

      // Community Records
      $parent_dh = entity_metadata_wrapper('node', $nid);
      if ($community_records = $parent_dh->field_community_record_children->value()) {

        $tab_settings = array(
          'ajax' => 0,
          'default_tab' => 0,
          'title' => 'DH Tabs',
          'renderer' => 'quicktabs',
          'style' => 'Excel',
          'hide_empty_tabs' => 1,
        );

        // Parent tab
        $parent_parent_community = node_load($node->field_community_ref[LANGUAGE_NONE][0]['nid']);
        $dh_tabs[] = array(
          'type' => 'node',
          'nid' => $nid,
          'view_mode' => 'full',
          'title' => $parent_parent_community->title . ' Record',
          'hide_title' => 0,
          #'weight' => 0,
        );

        foreach ($community_records as $community_record) {

          global $user;
          if (mukurtu_protocol_field_node_access($community_record, 'view', $user) == 'allow') {

            // Tab title
            $community_record_parent_communities = array();
            foreach ($community_record->field_community_ref[LANGUAGE_NONE] as $community_record_parent_community) {
              $community_record_parent_community_node = node_load($community_record_parent_community['nid']);
              $community_record_parent_communities[] = $community_record_parent_community_node->title;
            }
            $community_record_tab_title = implode(' / ', $community_record_parent_communities) . ' Record';

            // Create the tab
            $dh_tabs[] = array(
              'type' => 'node',
              'nid' => $community_record->nid,
              'view_mode' => 'community_record',
              'title' => $community_record_tab_title,
              'hide_title' => 0,
              #'weight' => 0,
            );
          }

          // User does not have view access to the Community Record. Create an empty tab (which does not render) to maintain tab index for direct linking to tabs
          else {
            $dh_tabs[] = array();
          }
        }

        // Add the rendered quicktabs to the built page content
        $community_record_tabs = quicktabs_build_quicktabs("community-record", $tab_settings, $dh_tabs);
        foreach($community_record_tabs['content']['content']['tabs']['tablinks'] as $key => $tab) {
            // Shorten title if necessary.  Long titles break the tabs.
             if(strlen($tab['#title']) > 25) {
                 $comma_break_pos = strpos($tab['#title'], ',', 18);
                 $colon_break_pos = strpos($tab['#title'], ':', 18);
                 $word_break_pos = strpos($tab['#title'], ' ', 18);
                 $break_pos = 25;

                 if($comma_break_pos > 0) {
                     $break_pos = $comma_break_pos;
                 }

                 if($colon_break_pos > 0 && $colon_break_pos < $break_pos) {
                     $break_pos = $colon_break_pos;
                 }

                 if($word_break_pos > 0 && $word_break_pos < $break_pos) {
                     $break_pos = $word_break_pos;
                 }

                 $community_record_tabs['content']['content']['tabs']['tablinks'][$key]['#options']['attributes']['title'] = $tab['#title'];
                 $community_record_tabs['content']['content']['tabs']['tablinks'][$key]['#title'] = substr($tab['#title'], 0, $break_pos) . '...';
             }
        }

        $dh_page_content .= drupal_render($community_record_tabs);
      }

      // Node does not have community records. Render DH normally.
      else {
        $dh_page_content .= drupal_render(node_view($node, 'full'));
      }

      // Rewrite the output for DH nodes with our built DH page content
      $data['content']['system_main']['#markup'] = $dh_page_content;
    }
  }
}

function ma_digital_heritage_book_page_navigation_buttons ($node) {
  $output = "";

  $parent_emw = entity_metadata_wrapper('node', $node);
  $children = $parent_emw->field_book_children->value();
  if ($node->field_book_children) {
    $first = $left = $node;
    $right = $children[0];
  }

  // Child pages show arrows left, right, and up arrows
  elseif ($node->field_book_parent) {
    $child_emw = entity_metadata_wrapper('node', $node);
    $parent_node = $child_emw->field_book_parent->value();
    $first = $parent_node;
    $parent_emw = entity_metadata_wrapper('node', $parent_node);
    $children = $parent_emw->field_book_children->value();
    foreach ($children as $child_index => $child) {
      if ($child->nid == $node->nid) {
        if (isset ($children[$child_index -1])) {
          $left = $children[$child_index -1];
        }
        else {
          $left = $parent_node;
        }
        if (isset ($children[$child_index +1])) {
          $right = $children[$child_index +1];
        }
        else {
          $right = $node;
        }
        break;
      }
    }
  }

  // Render the navigation for all parent and child pages
  if (count($children)) {
    $last = end ($children);
    $output .= '<div class = "dh-book-nav">';
    $output .= '<span class = "nav-button">' . l('<<', 'node/' . $first->nid) . '</span>';
    $output .= '<span class = "nav-button">' . l('<', 'node/' . $left->nid) . '</span>';
    $output .= '<span class = "nav-button">' . l('>', 'node/' . $right->nid) . '</span>';
    $output .= '<span class = "nav-button">' . l('>>', 'node/' . $last->nid) . '</span>';

    // Plus button to add a child page if user is the node owner
    global $user;
    if ($node->uid == $user->uid) {
      $output .= l('+', 'node/add/digital-heritage/book-page/' . $node->nid);
    }

    $output .= '</div>';
    return $output;
  }

}


function ma_digital_heritage_book_page_contents ($node) {

  // Parent book pages show a table of contents
  $toc = '<ol><li>' . $node->title .'</li>';
  $parent_emw = entity_metadata_wrapper('node', $node);
  $children = $parent_emw->field_book_children->value();
  foreach ($children as $child) {
    $toc .= '<li>' . l($child->title, 'node/' . $child->nid) . '</li>';
  }
  $toc .= '</ol>';

  return '<div class = "dh-book-nav-toc">' . $toc . '</div>';
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function ma_digitalheritage_form_node_delete_confirm_alter(&$form, &$form_state) {

  // Extra confirmation text when deleting a book parent
  if (count($form['#node']->field_book_children )) {
    $form['description']['#markup'] = "<p><b>This will delete ALL the pages in this book.</b></p>" . $form['description']['#markup'];
    drupal_set_title ("Are you sure you want to delete the entire book for <i>" . $form['#node']->title . "</i>?",  PASS_THROUGH);
  }

  // Extra confirmation text when deleting a community record parent
  if (count($form['#node']->field_community_record_children )) {
    $form['description']['#markup'] = "<p><b>This will delete all of its Community Records.</b></p>" . $form['description']['#markup'];
    drupal_set_title ("Are you sure you want to delete <i>" . $form['#node']->title . "</i> and all of its Community Records?",  PASS_THROUGH);
  }
}
